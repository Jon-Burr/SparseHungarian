import numpy as np
import argparse
import json

def parse_commandline_args():
  parser = argparse.ArgumentParser(
      description = "Generate N points to test Hungarian matching. The first set are generated uniformly in eta-phi space, the second are generated by applying a translation in a random direction with dR sampled from a Gaussian distribution"
      )

  parser.add_argument("-n", "--n-points", default=20, type=int, help="The number of points to create")
  parser.add_argument("-N", "--n-extra-points", default=5, type=int, help="The number of extra random points to create in the second set")
  parser.add_argument("-s", "--sigma-dr", default=0.1, type=float, help="The width of the gaussian used to generate the dR displacements")
  parser.add_argument("-r", "--radius", default = 0.2, type=float, help="The MaxDR value recorded to the output file (used in the matching)")
  parser.add_argument("-o", "--out-file", default="points.json", type=str, help="The file to write the output file to")
  parser.add_argument("-e", "--max-eta", default=2.4, help="Generate points between +-max_eta")
  parser.add_argument("-S", "--seed", default=0, type=int, help="The seed for the Numpy RandomState")

  return parser.parse_args()

def generate_points(n_points, n_extra_points, max_eta, displacement, random_state):
  # First create the points for the nominal set
  eta_a = random_state.uniform(-max_eta, max_eta, n_points)
  phi_a = random_state.uniform(0, 2*np.pi, n_points)
  points_a = zip(phi_a, eta_a)

  # Now generate the displacements
  displacement_dR = random_state.normal(0, displacement, n_points)
  displacement_dir = random_state.uniform(0, 2*np.pi, n_points)

  # combine to produce the points
  eta_b = eta_a + displacement_dR*np.cos(displacement_dir)
  phi_b = np.mod(phi_a + displacement_dR*np.sin(displacement_dir), 2*np.pi)

  eta_b = np.concatenate([eta_b, random_state.uniform(-max_eta, max_eta, n_extra_points)])
  phi_b = np.concatenate([phi_b, random_state.uniform(0, 2*np.pi, n_extra_points)])

  # Shuffle the 'B' points to make it harder for the matching program
  points_b = zip(phi_b, eta_b)
  random_state.shuffle(points_b)

  return points_a, points_b

if __name__ == "__main__":
  args = parse_commandline_args()
  rs = np.random.RandomState(args.seed)
  points_a, points_b = generate_points(
      n_points = args.n_points,
      n_extra_points = args.n_extra_points,
      max_eta = args.max_eta,
      displacement = args.sigma_dr,
      random_state = rs)

  with open(args.out_file, 'w') as fp:
    out_dict = {
      "PointsA" : points_a,
      "PointsB" : points_b,
      "MaxDR"   : args.radius,
      "MaxEta"  : args.max_eta
    }
    json.dump(out_dict, fp, indent=4)

